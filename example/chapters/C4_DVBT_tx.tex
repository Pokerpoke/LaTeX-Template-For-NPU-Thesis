%!TEX root = ../paper.tex
\chapter{DVB-T发射端}
	\section{能量扩散}
		\par 当发射的信号过于集中在某一频段上，将对与其共用频段的其他系统或设备造成较大干扰。人为地对发射信号进行随机化或者加扰，可以使原本集中的信号能量均匀分布。同时，由于添加的随机码为伪随机码，所以在接收端很容易进行去随机化。在数字通信过程中，通过添加伪随机信号还能缩短连续的“0”或者连续的“1”的长度，接收端提取定时信号将变得更加容易。\cite{数字电视DVB标准能量扩散的FPGA设计与实现_肖闽进}
		\par MPEG-2的传输复用包长为188字节，包括一个同步字节，如图\ref{fig:MPEG_2_TS}所示。		\input{figures/mpeg_2_TS.tex}
		\par 其中同步字节为0x47,传送时从高位开始送入即（0100 0111）的0开始送入，由伪随机二进制（PRBS，Pseudo Random Binary Sequence）和码流数据按位异或完成，结构如图\ref{fig:PRBS}所示。
		\input{figures/PRBS.tex}
		\par PRBS的生成多项式为$g(x)=1+X^{14}+X^{15}$，伪随机寄存器中的初始序列是“1001 0101 0000 000”，每8个传输包初始化一次。同时，为了方便接收，每8个传输包为一组，并对每8个传输包的第一个包的同步字节按比特取反，即由0x47变为0xB8。随机化从第1个传输包的同步字节sync后的第1个比特开始进行，但在随后的7个传输包中的同步字节，继续产生伪随机码，但是不对输入的同步字节进行加扰，同步字节保持原状，这样PRBS的周期为$188*8-1=1503$字节。输入码流中断或者不是MPEG-2 TS码流格式时，随机化继续进行，插入空白字节与同步字节完成空包处理，接收端识别全零的空包并将其删除。
		\par 程序实现主要代码见代码\ref{code:prbs}：
		\begin{lstlisting}[caption = {能量扩散}, label = {code:prbs}, language = C++ ]
void dvbt_energy_dispersal_impl::clock_prbs(int clocks)
{
	int res = 0;
	int feedback = 0;

	for (int i = 0; i < clocks; i++) {
	feedback = ((d_reg >> (14 - 1)) ^ (d_reg >> (15 - 1))) & 0x1;
	d_reg = ((d_reg << 1) | feedback) & 0x7fff;
	res = (res << 1) | feedback;
	}
	return res;
}
		\end{lstlisting}
	\section{RS编码}
		\par DVB-T的外编码采用RS编码（Reed-Solomon）编码，RS编码是一种线性分组循环码，以长度为$n$的一组符号为单位处理，组中的$n$个符号由$k$个欲传输的信息符号按一定关系生成的，RS编码具有极强的随机错误和突发错误纠正能力。
		\par DVB-T系统使用的是由RS（255，239，$t$=8）衍生出的删余RS（204，188，$t$=8）码，通过对每个随机化后的188字节的传输包编码，通过生成多项式，生成一个误码保护包，RS编码从同步字节（0x47）或者倒相后的同步字节（0xB8）开始，误码保护包如图\ref{fig:rs_204_188}。\cite{RS编码器的设计与实现_游余新}
		\input{figures/rs_204_188.tex}
		\par 可以看到，编码后的总长度为204字节，有效数据为188字节，最多可以校正8个字节的随机误码错误。
		\par RS码生成多项式为：
		\begin{equation}
			g(x)=(x+\lambda ^0)(x+\lambda ^1)(x+\lambda ^2)...(x+\lambda ^{15})
		\end{equation}
		\par 其中$\lambda$=0x02。
		\par 域生成多项式为：
		\begin{equation}
			p(x)=x^8+x^4+x^3+x^2+1
		\end{equation}
		\par 如果想要通过RS（255，239，$t$=8）编码器，可以在传输包前面增加51个全零字节，经过编码程序以后，在将这些无用的全零字节删除，最终产生$N$=204字节的RS码字。
		\par RS编码初始化主要代码见代码\ref{code:rs_init}，RS编码主要代码见代码\ref{code:rs_encode}。
		\begin{lstlisting}[caption = {RS编码初始化}, label={code:rs_init}, language = C++ ]
void dvbt_reed_solomon::rs_init(int lambda, int n, int k, int t)
{
	d_n = n; d_k = k; d_t = t;
	// 2t = n - k, dmin = 2t + 1 = n -k + 1

	d_l = new unsigned char[d_n + 1];
	if (d_l == NULL) {
	std::cout << "Cannot allocate memory for d_l" << std::endl;
	exit(1);
	}

	d_g = new unsigned char[2 * d_t + 1];
	if (d_g == NULL) {
	std::cout << "Cannot allocate memory for d_g" << std::endl;
	delete [] d_l;
	exit(1);
	}

	//Generate roots of lambda
	d_l[0] = 1;

	for (int i = 1; i <= d_n; i++) {
	d_l[i] = gf_mul(d_l[i - 1], lambda);
	}

	//Init Generator polynomial buffer
	for (int i = 0; i <= (2*t); i++) {
	d_g[i] = 0;
	}

	//Start with x+lambda^0
	d_g[0] = 1;

	//Create generator polynomial
	for (int i = 1; i <= (2 * t); i++) {
	for (int j = i; j > 0; j--) {
		if (d_g[j] != 0) {
		d_g[j] = gf_add(d_g[j - 1], gf_mul(d_g[j], d_l[i - 1]));
		}
		else {
		d_g[j] = d_g[j - 1];
		}
	}

	d_g[0] = gf_mul(d_g[0], d_l[i - 1]);
	}

	// Init syndrome array
	d_syn = new unsigned char[2 * d_t + 1];
	if (d_syn == NULL) {
	std::cout << "Cannot allocate memory for d_syn" << std::endl;
	delete [] d_g;
	delete [] d_l;
	exit(1);
	}
}
		\end{lstlisting}
		\begin{lstlisting}[caption = {RS编码}, label = {code:rs_encode}, language = C++ ]
int dvbt_reed_solomon::rs_encode(unsigned char *data_in, unsigned char *parity)
{
	memset(parity, 0, 2 * d_t);

	for (int i = 0; i < d_k; i++) {
	int feedback = gf_add(data_in[i], parity[0]);

	if (feedback != 0) {
		for (int j = 1; j < (2 * d_t); j++) {
		if (d_g[2 * d_t - j] != 0) {
			parity[j] = gf_add(parity[j], gf_mul(feedback, d_g[2 * d_t - j]));
		}
		}
	}

	//Shift the register
	memmove(&parity[0], &parity[1], (2 * d_t) - 1);

	if (feedback != 0) {
		parity[2 * d_t - 1] = gf_mul(feedback, d_g[0]);
	}
	else {
		parity[2 * d_t - 1] = 0;
	}
	}

	return (0);
}
		\end{lstlisting}
	\section{卷积交织}
		\par DVB-T系统的外交织采用的是深度$I$=12，基数为17的，基于字节的卷积交织，现用一个$M$=3的例子说明，此时卷积交织工作过程如图\ref{fig:convolutional_interleaver}所示。第一行直通，第二行有$M$=3个存储器，第三行有$2M$=6个存储器,输入、输出的每个字节由同步开关进行控制，第二行延时$M$个字节，第三行延时$2M$个字节，解交织的过程与此相反。输入输出数据流如图\ref{fig:convolutional_interleaver_data_structure}所示\cite{用FPGA实现DVB标准中的卷积交织_刘静}，这样就将原来的数据分散发送了。
		\input{figures/convolutional_interleaver.tex}
		\input{figures/convolutional_interleaver_data_structure.tex}
		\par DVB-T中使用的卷积交织，$M$=17，即第一行直通，第二行延时17字节，第三行延时2*17=34字节，以此类推，总过有12层，同步字节（$\overline{\text{SYNC}}$和$\text{SYNC}_n$）总是通过第一行进行交织。
		\par 程序实现主要代码见代码\ref{code:convolutional_interleaver}。
		\begin{lstlisting}[caption = {卷积交织},label = {code:convolutional_interleaver},language = C++ ]
int dvbt_convolutional_interleaver_impl::work (int noutput_items,
				gr_vector_const_void_star &input_items,
				gr_vector_void_star &output_items)
{
	const unsigned char *in = (const unsigned char *) input_items[0];
	unsigned char *out = (unsigned char *) output_items[0];

	for (int i = 0; i < (noutput_items / d_I); i++) {
	//Process one block of I symbols
	for (unsigned int j = 0; j < d_shift.size(); j++) {
		d_shift[j]->push_front(in[(d_I * i) + j]);
		out[(d_I * i) + j] = d_shift[j]->back();
		d_shift[j]->pop_back();
	}
	}
	return noutput_items;
}
		\end{lstlisting}
	\section{内编码(卷积编码)}
		\par DVB-T系统的内编码采用卷积编码，卷积码是由$k$个信息比特编码成$n(n>k)$比特码组，编码出的l比特的码组值，不仅与当前码字中的k个信息比特值有关，而且与其前面$N-1$个码字中的$(N-1)xk$个信息比特值有关，也即当前码组内的$n$个码元，它们的值取决于$N$个码组内的全部信息码元，$N$可称为卷积码编码的约束长度。
		\par DVB-T系统可以选择几种由码率为1/2的主卷积码删余后的卷积码。无论是等级或非等级传送模式，对于某一给定业务的数据率，系统可选择最适当的码率。主码的生成多项式，对$X$路输出是$G_1=171_{OCT}$，对$Y$路输出是$G_2=133_{OCT}$。图\ref{fig:inner_coder}是主卷积码生成结构图。
		\input{figures/inner_coder.tex}
		\par 除了1/2码率的主码外，系统还可以按照图\ref{fig:inner_coder_slash}使用码率为2/3，3/4，5/6，7/8的删余卷积码。
		\input{figures/inner_coder_slash.tex}
		\par 删除卷积码的构造方法如表\ref{table:inner_coder_slash}，优先发送X1。
		\input{tables/inner_coder_slash.tex}
	\section{比特交织}
		\par DVB-T系统的内交织采用比特交织和符号交织，这两种交织都是基于块结构的。
		\par 内编码后的比特流通过解复用器后进入比特交织器，根据不同的映射模式分成$v$个子流。非等级模式下的对应关系如表\ref{table:bit_inner_interleaver_v}：
		\begin{table}[!hbp]
			\centering
			\caption{非等级模式下对应关系}
			\begin{tabular*}{5cm}{l|l}
				\hline\hline
				QPSK & $v$=2 \\
				\hline
				16QAM & $v$=4 \\
				\hline
				64QAM & $v$=6 \\
				\hline\hline
			\end{tabular*}
			\label{table:bit_inner_interleaver_v}
		\end{table}
		\par 16QAM解复用模型如图\ref{fig:bit_inner_interleaver}，$x_0$映射到$b_{0,0}$，$x_1$映射到$b_{1,0}$，$x_2$映射到$b_{2,0}$，$x_3$映射到$b_{3,0}$\cite{DVB—T中内交织与解交织的算法及实现_徐翼}。
		\input{figures/bit_inner_interleaver.tex}
		\par 比特交织仅在有用的数据上进行，比特交织块的大小为126字节，在2K模式下每个OFDM符号中的有效数据在交织过程中重复12次，8K模式下需要重复48次。每一路比特交织器，输入的比特向量定义为：
		\begin{equation}
			B(e)=(b_{e,0},b_{e,1},b_{e,2},\cdots b_{e,125}),e\in[0,v-1]
		\end{equation}
		\par 交织后的输出向量定义为：
		\begin{equation}
			A(e)=(a_{e,0},a_{e,1},a_{e,2},\cdots a_{e,125}),e\in[0,v-1]
		\end{equation}
		\par 则：
		\begin{equation}
			a_{e,w}=b_{e,He(w)},w\in[0,125]
		\end{equation}
		\par $He_{w}$为一置换函数，对于每一路交织器置换函数$He_{w}$均不相同，$He_{w}$定义如表\ref{table:inner_interleaver_hew}。以交织器I3为例，$w$为输入数据地址，$H(w)$为输出数据地址，即先将输入数据输入到126个地址空间中，输出时先输出地址42~125中的数据，在输出地址0~41中的数据。
		\input{tables/inner_interleaver_hew}
		\par $v$比特交织器的输出共同组成了一个$v$比特数据字。因此，整个比特交织器的输出是一个$v$比特字$y'$，其中I0支路的输出为最高位。
		\begin{equation}
			y_w'=(a_{0,w},a_{1,w},a_{2,w},\cdots a_{v-1,w},),w\in[0,125],v\in[1,6]
		\end{equation}
		\par 程序实现主要代码见代码\ref{code:bit_inner_interleaver}。
		\begin{lstlisting}[caption = {比特内交织}, label = {code:bit_inner_interleaver}, language = C++ ]
int dvbt_bit_inner_interleaver_impl::general_work (int noutput_items,
			gr_vector_int &ninput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
	const unsigned char *inh = (const unsigned char *) input_items[0];
	const unsigned char *inl = (const unsigned char *) input_items[1];
	unsigned char *out = (unsigned char *) output_items[0];

	int bmax = noutput_items * d_nsize / d_bsize;

	// First index of d_b is Bit interleaver number
	// Second index of d_b is the position inside the Bit interleaver
	unsigned char d_b[MAX_MODULATION_ORDER][INTERLEAVER_BLOCK_SIZE];

	for (int bcount = 0; bcount < bmax; bcount++) {
	for (int i = 0; i < d_bsize; i++) {
		if (d_hierarchy == NH) {
		int c = inh[bcount * d_bsize + i];

		// Create the demultiplexer
		for (int k = 0; k < d_v; k++) {
			d_b[d_perm[(d_v * i) + k]][i] = (c >> (d_v - k - 1)) & 1;
		}
		}
		else {
		int ch = inh[(bcount * d_bsize) + i];
		int cl = inl[(bcount * d_bsize) + i];

		// High priority input - first 2 streams
		for (int k = 0; k < 2; k++) {
			d_b[(d_v * i + k) % 2][(d_v * i + k) / 2] = (ch >> (1 - k)) & 1;
		}

		// Low priority input - (v - 2) streams
		for (int k = 2; k < (d_v - 2); k++) {
			d_b[d_perm[d_v * i + k]][(d_v * i + k) / (d_v - 2)] = (cl >> (d_v - k - 1)) & 1;
		}
		}
	}

	// Take one bit from each interleaver
	// and format the output

	for (int w = 0; w < d_bsize; w++) {
		int val = 0;

		for (int e = 0; e < d_v; e++) {
		val = (val << 1) | d_b[e][H(e, w)];
		}

		out[(bcount * d_bsize) + w] = val;
	}
	}

	// Tell runtime system how many input items we consumed on
	// each input stream.
	consume_each (noutput_items);

	// Tell runtime system how many output items we produced.
	return noutput_items;
}
		\end{lstlisting}
	\section{符号交织}
		\par 符号交织用于将$v$比特字映射到每个OFDM的有效载波上，其中2K模式下为1512个有效载波，8K模式下为6048个有效载波。
		\par 首先将比特交织输出的$N_{max}$个$v$比特字（2K模式下为$12*126=1512$个，8K模式下为$48*126=6048$个）顺序写入矢量$Y^{in}=(y_0^{in},y_1^{in},y_2^{in},\cdots,y_{N_{max}-1}^{in})$中，接下来对该矢量进行交织，其中2K模式下$N_{max}=1512$，8K模式下$N_{max}=6048$。经过交织后的矢量$Y^{out}=(y_0^{out},y_1^{out},y_2^{out},\cdots,y_{N_{max}-1}^{out})$定义为：
		\par OFDM帧中的偶数符号：
		\begin{equation}
			y_{H(q)}^{out}=y_q^{in}
		\end{equation}
		\par OFDM帧中的奇数符号：
		\begin{equation}
			y_q^{out}=y_{H(q)}^{in}
		\end{equation}
		\par 其中$H(q)$是DVB-T标准中定义的一个专门的置换函数。首先定义一个$N_r-1$位的二进制数$R'_i$，其中$N_r=\log_{2}M_{max}$（2K模式下$M_{max}=2048$，8K模式下$M_{max}=8192$），$R'_i$符号下面的规定：
		\begin{equation}
			\begin{array}{ll}
				R'_i[N_r-2,N_r-3,\cdots,1,0]=0,0,\cdots,0,0                                                                       & i={0,1}     \\
				R'_i[N_r-2,N_r-3,\cdots,1,0]=0,0,\cdots,0,1                                                                       & i=2         \\
				\{R'_i[N_r-3,N_r-4,\cdots,1,0]=R'_i[N_r-2,N_r-3,\cdots,2,1]                                                       & 2<i<M_{max} \\
				\quad\quad 2K\text{模式}:R'_i[9]=R'_{i-1}[0]\bigoplus R'_{i-1}[3]                                               &             \\
				\quad\quad 8K\text{模式}:R'_i[11]=R'_{i-1}[0]\bigoplus R'_{i-1}[1]\bigoplus R'_{i-1}[4]\bigoplus R'_{i-1}[46]\} &             \\
			\end{array}
		\end{equation}
		\par 再定义一个矢量$R_i$，矢量$R_i$由$R'_i$按如表\ref{table:symbol_interleaver_bit_replace}的要求置换得到\cite{DVB—T中内交织与解交织的算法及实现_徐翼}。
		\input{tables/symbol_interleaver_bit_replace.tex}
		\par 则$H(q)$符合以下算法：
		\par\noindent $q=0;$
		\par\noindent $for\quad (i=0;i<M_{max};i++)\{$
		\par\noindent $\qquad H(q)=(i\quad mod\quad 2)\cdot 2^{N_r-1}+\Sigma_{j=0}^{N_r-2}R_i(j)\cdot 2^j;$
		\par\noindent $\qquad if(H(q)<N_{max})$
		\par\noindent $\qquad\qquad q=q+1;$
		\par\noindent $\}$
	\section{星座映射}
		\par DVB-T系统采用正交频分复用传输（OFDM）传输，一个OFDM帧的所有数据载波调制采用格雷（Grey）映射的QPSK、16QAM、64QAM、非均匀16QAM或非均匀64QAM映射为复数Z。本设计采用16QAM均匀模式，其星座图如图\ref{fig:dvbt_map_16QAM}。
		\input{figures/dvbt_map_16QAM.tex}
		\par 其他模式星座图与之类似。
		\par 程序实现主要代码见代码\ref{code:dvbt_map}。
		\begin{lstlisting}[caption = {星座映射},label = {code:dvbt_map}, language = C++ ]
void dvbt_map_impl::make_constellation_points(int size, int step, int alpha)
{
	// The symmetry of the constellation is used to calculate
	// 16-QAM from QPSK and 64-QAM form 16-QAM

	int bits_per_axis = log2(size) / 2;
	int steps_per_axis = sqrt(size) / 2 - 1;

	for (int i = 0; i < size; i++) {
	// This is the quadrant made of the first two bits starting from MSB
	int q = i >> (2 * (bits_per_axis - 1)) & 3;
	// Sign for correctly calculate I and Q in each quadrant
	int sign0 = (q >> 1) ? -1 : 1; int sign1 = (q & 1) ? -1 : 1;

	int x = (i >> (bits_per_axis - 1)) & ((1 << (bits_per_axis - 1)) - 1);
	int y = i & ((1 << (bits_per_axis - 1)) - 1);

	int xval = alpha + (steps_per_axis - x) * step;
	int yval = alpha + (steps_per_axis - y) * step;

	int val = (bin_to_gray(x) << (bits_per_axis - 1)) + bin_to_gray(y);

	// ETSI EN 300 744 Clause 4.3.5
	// Actually the constellation is gray coded
	// but the bits on each axis are not taken in consecutive order
	// So we need to convert from b0b2b4b1b3b5->b0b1b2b3b4b5(QAM64)

	x = 0; y = 0;

	for (int j = 0; j < (bits_per_axis - 1); j++) {
		x += ((val >> (1 + 2 * j)) & 1) << j;
		y += ((val >> (2 * j)) & 1) << j;
	}

	val = (q << 2 * (bits_per_axis - 1)) + (x << (bits_per_axis - 1)) + y;

	// Keep corresponding symbol bits->complex symbol in one vector
	// Normalize the signal using gain
	d_constellation_points[val] = d_gain * gr_complex(sign0 * xval, sign1 * yval);
	}
}
		\end{lstlisting}
	\section{参考信号}
		\par DVB-T系统中2K模式和8K模式分别含有1705和6817个子载波，这些子载波的作用可以分为三类：
		\par （1）数据载波，负责传递MPEG-2 TS流信号。
		\par （2）传输参数信令载波（TPS: Transport Parameter Signaling）含有方便接收终端接收信号的所需的参数，例如：调制方式（QPSK，16QAM，64QAM），信号纠错码（1/2，2/3，3/4，5/6，7/8），2k和8k模式，保护间隔（1/4，1/8，1/16，1/32）等。
		\par （3） 导频信号载波（Pilot），用来帮助接收机对信号幅度及相位进行预估及校正，改善接收质量。
		\par 在有效载波数的基础上，通常会加入一些虚拟载波使其载波总数达到2的n次方，例如加入虚拟载波以后8k模式的总载波数量为8192，是2的13次方，2k模式的总载波数量为2048，是2的11次方，以方便计算机采用反向快速富里叶变换，这也是2k和8k模式名称的由来。在接收机端，通过采用快速富里叶变换，机顶盒可以解调出2k或8k的COFDM信号\cite{DVB—T编码调制的仿真和FPGA实现_王闯}。
		\par 即：
		\par 2K模式：
		\par 总载波数量1705=1512（数据）+17（传输参数信令）+176（导频）
		\par 8K模式：
		\par 总载波数量6817=7048（数据）+68（传输参数信令）+701（导频）
		\par 传数参数信令（TPS）是为了方便机顶盒的信道解码而发送的传输参数，对于2k模式TPS占用17个载波，对于8k模式TPS占用68个载波，它们所占用的载波序号见表\ref{table:tps_carrier}，它们所传输的信息是：调制方式，等级调制信息，保护间隔，纠错保护码，传输模式，超级帧中的帧序号，发射机所覆盖的蜂窝标识，等，详细含义见表\ref{table:tps}。
		\input{tables/tps_carrier.tex}
		\input{tables/tps.tex}
		\par 值得注意的是TPS信号既不是采用QPSK，也不是采用16QAM和64QAM的调制方式，而是采用比它们都更加抗干扰的BPSK调制，接收TPS信号的门限比QPSK还要低，机顶盒可以接收到TPS信号，未必可以接到数字电视信号。
		\par 本部分程序段过长，参见\href{https://github.com/gnuradio/gnuradio/blob/master/gr-dtv/lib/dvbt/dvbt\_reference\_signals\_impl.cc}{https://github.com/gnuradio/gnuradio/blob/master/gr-dtv/lib/dvbt/dvbt\_reference\_signals\_impl.cc}
	\section{IFFT}
		\par 傅里叶变换是将时域和频域联系起来的工具，将信号的时域表示用频域表示出来，傅里叶变换能够直接计算出给定时域信号在频域上的表示，反傅里叶变换为其逆过程，能够算出给定频域信号在时域的表示。
		\par 忽一人大呼“火起”，夫起大呼，妇亦起大呼。两儿齐哭。俄而百千人大呼，百千儿哭，百千犬吠。中间力拉崩倒之声，火爆声，呼呼风声，百千齐作；又夹百千求救声，曳屋许许声，抢夺声，泼水声。凡所应有，无所不有。虽人有百手，手有百指，不能指其一端；人有百口，口有百舌，不能名其一处也。傅里叶变换指其各端，名其处处\cite{zhihu:如何直观形象、生动有趣地给文科学生介绍傅立叶变换？}。
		\par OFDM的理论很久以前就提出来了，但是一直没有好的实现方式，因为需要计算出各个信号在时域上的叠加很困难，直到快速傅里叶变换的出现，大大降低了傅里叶变换的复杂度，能够很快地计算出信号在时域上的叠加以后的结果，使得OFDM的广泛使用成为可能。
		\par IFFT模块的功能相当于说：别麻烦发送N个子载波信号了，我直接算出你们在空中会叠加成啥样子吧；FFT模块的功能相当于说：别用老式的积分方法来去除其余的正交子载波了，我帮你一次把N个携带信号全算出来吧。就是这样，IFFT实现OFDM的系统用"数学的方法"，在发送端计算信号的叠加波形，在接收端去除正交子载波，从而大大简化了系统的复杂度\cite{给"小白"图示讲解OFDM的原理}。
		\par DVB-T发射系统中采反傅里叶变换，将频域信号的在时域上叠加后的结果一次性计算出来，再在接收端使用傅里叶变换进行还原。
	\section{OFDM循环前缀}
		\par 在传播过程中如果子载波的正交性遭到破环，会影响信号接收，造成信道间干扰（ICI），为了克服这种干扰，OFDM传播系统采取添加循环前缀的措施来减少信道间干扰。
	% \section{常数}
	\section{重采样}
		\par 信号的采样率，用于满足另一个系统的要求
	\section{USRP发射}
		% TODO: 图片、参数
		\par 
