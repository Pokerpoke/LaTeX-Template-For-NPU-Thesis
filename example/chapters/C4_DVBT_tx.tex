%!TEX root = ../paper.tex
\chapter{DVB-T发射端}
	\section{能量扩散}
		\par 当发射的信号过于集中在某一频段上，将对与其共用频段的其他系统或设备造成较大干扰。人为地对发射信号进行随机化或者加扰，可以使原本集中的信号能量均匀分布。同时，由于添加的随机码为伪随机码，所以在接收端很容易进行去随机化。在数字通信过程中，通过添加伪随机信号还能缩短连续的“0”或者连续的“1”的长度，接收端提取定时信号将变得更加容易。
		\par MPEG-2的传输复用包长为188字节，包括一个同步字节，如图\ref{fig:MPEG_2_TS}所示。\cite{数字电视DVB标准能量扩散的FPGA设计与实现_肖闽进}
		\input{figures/mpeg_2_TS.tex}
		\par 其中同步字节为0x47,传送时从高位开始送入即（0100 0111）的0开始送入，由伪随机二进制（PRBS，Pseudo Random Binary Sequence）和码流数据按位异或完成，结构如图\ref{fig:PRBS}所示。
		\input{figures/PRBS.tex}
		\par PRBS的生成多项式为$g(x)=1+X^{14}+X^{15}$，伪随机寄存器中的初始序列是“1001 0101 0000 000”，每8个传输包初始化一次。同时，为了方便接收，每8个传输包为一组，并对每8个传输包的第一个包的同步字节按比特取反，即由0x47变为0xB8。随机化从第1个传输包的同步字节sync后的第1个比特开始进行，但在随后的7个传输包中的同步字节，继续产生伪随机码，但是不对输入的同步字节进行加扰，同步字节保持原状，这样PRBS的周期为$188*8-1=1503$字节。输入码流中断或者不是MPEG-2 TS码流格式时，随机化继续进行，插入空白字节与同步字节完成空包处理，接收端识别全零的空包并将其删除。
		\par 主要程序实现如代码段\ref{code:prbs}：
		\begin{lstlisting}[caption = {能量扩散}, label = {code:prbs}, language = C++ ]
void dvbt_energy_dispersal_impl::clock_prbs(int clocks)
{
	int res = 0;
	int feedback = 0;

	for (int i = 0; i < clocks; i++) {
	feedback = ((d_reg >> (14 - 1)) ^ (d_reg >> (15 - 1))) & 0x1;
	d_reg = ((d_reg << 1) | feedback) & 0x7fff;
	res = (res << 1) | feedback;
	}
	return res;
}
		\end{lstlisting}
	\section{RS编码}
		\par DVB-T的外编码采用RS编码（Reed-Solomon）编码，RS编码是一种线性分组循环码，以长度为$n$的一组符号为单位处理，组中的$n$个符号由$k$个欲传输的信息符号按一定关系生成的，RS编码具有极强的随机错误和突发错误纠正能力。
		\par DVB-T系统使用的是由RS（255，239，$t$=8）衍生出的删余RS（204，188，$t$=8）码，通过对每个随机化后的188字节的传输包编码，通过生成多项式，生成一个误码保护包，RS编码从同步字节（0x47）或者倒相后的同步字节（0xB8）开始，误码保护包如图\ref{fig:rs_204_188}。\cite{RS编码器的设计与实现_游余新}
		\input{figures/rs_204_188.tex}
		\par 可以看到，编码后的总长度为204字节，有效数据为188字节，最多可以校正8个字节的随机误码错误。
		\par RS码生成多项式为：
		\begin{equation}
			g(x)=(x+\lambda ^0)(x+\lambda ^1)(x+\lambda ^2)...(x+\lambda ^{15})
		\end{equation}
		\par 其中$\lambda$=0x02。
		\par 域生成多项式为：
		\begin{equation}
			p(x)=x^8+x^4+x^3+x^2+1
		\end{equation}
		\par 如果想要通过RS（255，239，$t$=8）编码器，可以在传输包前面增加51个全零字节，经过编码程序以后，在将这些无用的全零字节删除，最终产生$N$=204字节的RS码字。
		\par RS编码初始化见代码段\ref{code:rs_init}，RS编码见代码段\ref{code:rs_encode}。
		\begin{lstlisting}[caption = {RS编码初始化}, label={code:rs_init}, language = C++ ]
void dvbt_reed_solomon::rs_init(int lambda, int n, int k, int t)
{
	d_n = n; d_k = k; d_t = t;
	// 2t = n - k, dmin = 2t + 1 = n -k + 1

	d_l = new unsigned char[d_n + 1];
	if (d_l == NULL) {
	std::cout << "Cannot allocate memory for d_l" << std::endl;
	exit(1);
	}

	d_g = new unsigned char[2 * d_t + 1];
	if (d_g == NULL) {
	std::cout << "Cannot allocate memory for d_g" << std::endl;
	delete [] d_l;
	exit(1);
	}

	//Generate roots of lambda
	d_l[0] = 1;

	for (int i = 1; i <= d_n; i++) {
	d_l[i] = gf_mul(d_l[i - 1], lambda);
	}

	//Init Generator polynomial buffer
	for (int i = 0; i <= (2*t); i++) {
	d_g[i] = 0;
	}

	//Start with x+lambda^0
	d_g[0] = 1;

	//Create generator polynomial
	for (int i = 1; i <= (2 * t); i++) {
	for (int j = i; j > 0; j--) {
		if (d_g[j] != 0) {
		d_g[j] = gf_add(d_g[j - 1], gf_mul(d_g[j], d_l[i - 1]));
		}
		else {
		d_g[j] = d_g[j - 1];
		}
	}

	d_g[0] = gf_mul(d_g[0], d_l[i - 1]);
	}

	// Init syndrome array
	d_syn = new unsigned char[2 * d_t + 1];
	if (d_syn == NULL) {
	std::cout << "Cannot allocate memory for d_syn" << std::endl;
	delete [] d_g;
	delete [] d_l;
	exit(1);
	}
}
		\end{lstlisting}
		\begin{lstlisting}[caption = {RS编码}, label = {code:rs_encode}, language = C++ ]
int dvbt_reed_solomon::rs_encode(unsigned char *data_in, unsigned char *parity)
{
	memset(parity, 0, 2 * d_t);

	for (int i = 0; i < d_k; i++) {
	int feedback = gf_add(data_in[i], parity[0]);

	if (feedback != 0) {
		for (int j = 1; j < (2 * d_t); j++) {
		if (d_g[2 * d_t - j] != 0) {
			parity[j] = gf_add(parity[j], gf_mul(feedback, d_g[2 * d_t - j]));
		}
		}
	}

	//Shift the register
	memmove(&parity[0], &parity[1], (2 * d_t) - 1);

	if (feedback != 0) {
		parity[2 * d_t - 1] = gf_mul(feedback, d_g[0]);
	}
	else {
		parity[2 * d_t - 1] = 0;
	}
	}

	return (0);
}
		\end{lstlisting}
	\section{卷积交织}
		\par DVB-T系统的外交织采用的是深度$I$=12，基数为17的，基于字节的卷积交织，现用一个$M$=3的例子说明，此时卷积交织工作过程如图\ref{fig:convolutional_interleaver}所示。第一行直通，第二行有$M$=3个存储器，第三行有$2M$=6个存储器,输入、输出的每个字节由同步开关进行控制，第二行延时$M$个字节，第三行延时$2M$个字节，解交织的过程与此相反。输入输出数据流如图\ref{fig:convolutional_interleaver_data_structure}所示\cite{用FPGA实现DVB标准中的卷积交织_刘静}，这样就将原来的数据分散发送了。
		\input{figures/convolutional_interleaver.tex}
		\input{figures/convolutional_interleaver_data_structure.tex}
		\par DVB-T中使用的卷积交织，$M$=17，即第一行直通，第二行延时17字节，第三行延时2*17=34字节，以此类推，总过有12层，同步字节（$\overline{\text{SYNC}}$和$\text{SYNC}_n$）总是通过第一行进行交织。
		\par 主要程序实现见代码段\ref{code:convolutional_interleaver}。
		\begin{lstlisting}[caption = {卷积交织},label = {code:convolutional_interleaver},language = C++ ]
int dvbt_convolutional_interleaver_impl::work (int noutput_items,
				gr_vector_const_void_star &input_items,
				gr_vector_void_star &output_items)
{
	const unsigned char *in = (const unsigned char *) input_items[0];
	unsigned char *out = (unsigned char *) output_items[0];

	for (int i = 0; i < (noutput_items / d_I); i++) {
	//Process one block of I symbols
	for (unsigned int j = 0; j < d_shift.size(); j++) {
		d_shift[j]->push_front(in[(d_I * i) + j]);
		out[(d_I * i) + j] = d_shift[j]->back();
		d_shift[j]->pop_back();
	}
	}
	return noutput_items;
}
		\end{lstlisting}
	\section{内编码(卷积编码)}
		\par DVB-T系统的内编码采用卷积编码，卷积码是由$k$个信息比特编码成$n(n>k)$比特码组，编码出的l比特的码组值，不仅与当前码字中的k个信息比特值有关，而且与其前面$N-1$个码字中的$(N-1)xk$个信息比特值有关，也即当前码组内的$n$个码元，它们的值取决于$N$个码组内的全部信息码元，$N$可称为卷积码编码的约束长度。
		\par DVB-T系统可以选择几种由码率为1/2的主卷积码删余后的卷积码。无论是等级或非等级传送模式，对于某一给定业务的数据率，系统可选择最适当的码率。主码的生成多项式，对$X$路输出是$G_1=171_{OCT}$，对$Y$路输出是$G_2=133_{OCT}$。图\ref{fig:inner_coder}是主卷积码生成结构图。
		\input{figures/inner_coder.tex}
		\par 除了1/2码率的主码外，系统还可以按照图\ref{fig:inner_coder_slash}使用码率为2/3，3/4，5/6，7/8的删余卷积码。
		\input{figures/inner_coder_slash.tex}
		\par 删除卷积码的构造方法如表\ref{table:inner_coder_slash}，优先发送X1。
		\input{tables/inner_coder_slash.tex}
	\section{比特交织}
		\par DVB-T系统的内交织采用比特交织和符号交织，这两种交织都是基于块结构的。
		\par 内编码后的比特流通过解复用器后进入比特交织器，根据不同的映射模式分成$v$个子流。非等级模式下的对应关系如表\ref{table:bit_inner_interleaver_v}：
		\begin{table}[!hbp]
			\centering
			\caption{非等级模式下对应关系}
			\begin{tabular*}{5cm}{l|l}
			\hline\hline
			QPSK & $v$=2 \\
			\hline
			16QAM & $v$=4 \\
			\hline
			64QAM & $v$=6 \\
			\hline\hline
			\end{tabular*}
			\label{table:bit_inner_interleaver_v}
		\end{table}
		\par 16QAM解复用模型如图\ref{fig:bit_inner_interleaver}，$x_0$映射到$b_{0,0}$，$x_1$映射到$b_{1,0}$，$x_2$映射到$b_{2,0}$，$x_3$映射到$b_{3,0}$\cite{DVB—T中内交织与解交织的算法及实现_徐翼}。
		\input{figures/bit_inner_interleaver.tex}
		\par 比特交织仅在有用的数据上进行，比特交织块的大小为126字节，在2K模式下每个OFDM符号中的有效数据在交织过程中重复12次，8K模式下需要重复48次。每一路比特交织器，输入的比特向量定义为：
		\begin{equation}
			B(e)=(b_{e,0},b_{e,1},b_{e,2},\cdots b_{e,125}),e\in[0,v-1]
		\end{equation}
		\par 交织后的输出向量定义为：
		\begin{equation}
			A(e)=(a_{e,0},a_{e,1},a_{e,2},\cdots a_{e,125}),e\in[0,v-1]
		\end{equation}
		\par 则：
		\begin{equation}
			a_{e,w}=b_{e,He(w)},w\in[0,125]
		\end{equation}
		\par $He_{w}$为一置换函数，对于每一路交织器置换函数$He_{w}$均不相同，$He_{w}$定义如表\ref{table:inner_interleaver_hew}。以交织器I3为例，$w$为输入数据地址，$H(w)$为输出数据地址，即先将输入数据输入到126个地址空间中，输出时先输出地址42~125中的数据，在输出地址0~41中的数据。
		\input{tables/inner_interleaver_hew}
		\par $v$比特交织器的输出共同组成了一个$v$比特数据字。因此，整个比特交织器的输出是一个$v$比特字$y'$，其中I0支路的输出为最高位。
		\begin{equation}
			y_w'=(a_{0,w},a_{1,w},a_{2,w},\cdots a_{v-1,w},),w\in[0,125],v\in[1,6]
		\end{equation}
		\par 程序实现见代码段\ref{code:bit_inner_interleaver}。
		\begin{lstlisting}[caption = {比特内交织}, label = {code:bit_inner_interleaver}, language = C++ ]
int dvbt_bit_inner_interleaver_impl::general_work (int noutput_items,
			gr_vector_int &ninput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
	const unsigned char *inh = (const unsigned char *) input_items[0];
	const unsigned char *inl = (const unsigned char *) input_items[1];
	unsigned char *out = (unsigned char *) output_items[0];

	int bmax = noutput_items * d_nsize / d_bsize;

	// First index of d_b is Bit interleaver number
	// Second index of d_b is the position inside the Bit interleaver
	unsigned char d_b[MAX_MODULATION_ORDER][INTERLEAVER_BLOCK_SIZE];

	for (int bcount = 0; bcount < bmax; bcount++) {
	for (int i = 0; i < d_bsize; i++) {
		if (d_hierarchy == NH) {
		int c = inh[bcount * d_bsize + i];

		// Create the demultiplexer
		for (int k = 0; k < d_v; k++) {
			d_b[d_perm[(d_v * i) + k]][i] = (c >> (d_v - k - 1)) & 1;
		}
		}
		else {
		int ch = inh[(bcount * d_bsize) + i];
		int cl = inl[(bcount * d_bsize) + i];

		// High priority input - first 2 streams
		for (int k = 0; k < 2; k++) {
			d_b[(d_v * i + k) % 2][(d_v * i + k) / 2] = (ch >> (1 - k)) & 1;
		}

		// Low priority input - (v - 2) streams
		for (int k = 2; k < (d_v - 2); k++) {
			d_b[d_perm[d_v * i + k]][(d_v * i + k) / (d_v - 2)] = (cl >> (d_v - k - 1)) & 1;
		}
		}
	}

	// Take one bit from each interleaver
	// and format the output

	for (int w = 0; w < d_bsize; w++) {
		int val = 0;

		for (int e = 0; e < d_v; e++) {
		val = (val << 1) | d_b[e][H(e, w)];
		}

		out[(bcount * d_bsize) + w] = val;
	}
	}

	// Tell runtime system how many input items we consumed on
	// each input stream.
	consume_each (noutput_items);

	// Tell runtime system how many output items we produced.
	return noutput_items;
}
		\end{lstlisting}
	\section{符号交织}
	\par 符号交织用于将$v$比特字映射到每个OFDM的有效载波上，其中2K模式下为1512个有效载波，8K模式下为6048个有效载波。
	\par 首先将比特交织输出的$N_{max}$个$v$比特字（2K模式下为$12*126=1512$个，8K模式下为$48*126=6048$个）顺序写入矢量$Y^{in}=(y_0^{in},y_1^{in},y_2^{in},\cdots,y_{N_{max}-1}^{in})$中，接下来对该矢量进行交织，其中2K模式下$N_{max}=1512$，8K模式下$N_{max}=6048$。经过交织后的矢量$Y^{out}=(y_0^{out},y_1^{out},y_2^{out},\cdots,y_{N_{max}-1}^{out})$定义为：
	\par OFDM帧中的偶数符号：
	\begin{equation}
		y_{H(q)}^{out}=y_q^{in}
	\end{equation}
	\par OFDM帧中的奇数符号：
	\begin{equation}
		y_q^{out}=y_{H(q)}^{in}
	\end{equation}
	\par 其中$H(q)$是DVB-T标准中定义的一个专门的置换函数。首先定义一个$N_r-1$位的二进制数$R'_i$，其中$N_r=\log_{2}M_{max}$（2K模式下$M_{max}=2048$，8K模式下$M_{max}=8192$），$R'_i$符号下面的规定：
	\begin{equation}
	\begin{array}{ll}
		R'_i[N_r-2,N_r-3,\cdots,1,0]=0,0,\cdots,0,0 & i={0,1} \\
		R'_i[N_r-2,N_r-3,\cdots,1,0]=0,0,\cdots,0,1 & i=2\\
		\{R'_i[N_r-3,N_r-4,\cdots,1,0]=R'_i[N_r-2,N_r-3,\cdots,2,1] & 2<i<M_{max}\\
		\quad\quad 2K\text{模式}:R'_i[9]=R'_{i-1}[0]\bigoplus R'_{i-1}[3] & \\
		\quad\quad 8K\text{模式}:R'_i[11]=R'_{i-1}[0]\bigoplus R'_{i-1}[1]\bigoplus R'_{i-1}[4]\bigoplus R'_{i-1}[46]\} & \\
	\end{array}
	\end{equation}
	\par 再定义一个矢量$R_i$，矢量$R_i$由$R'_i$按如表\ref{table:symbol_interleaver_bit_replace}的要求置换得到。
	\input{tables/symbol_interleaver_bit_replace.tex}
	\par 则$H(q)$符合以下算法：
	\par\noindent $q=0;$
	\par\noindent $for\quad (i=0;i<M_{max};i++)\{$
	\par\noindent $\qquad H(q)=(i\quad mod\quad 2)\cdot 2^{N_r-1}+\Sigma_{j=0}^{N_r-2}R_i(j)\cdot 2^j;$
	\par\noindent $\qquad if(H(q)<N_{max})$
	\par\noindent $\qquad\qquad q=q+1;$
	\par\noindent $\}$
	\section{星座映射}
	\par DVB-T系统采用正交频分复用传输（OFDM）传输，一个OFDM帧的所有数据载波调制采用格雷（Grey）映射的QPSK、16QAM、64QAM、非均匀16QAM或非均匀64QAM映射为复数Z。本设计采用16QAM均匀模式，其星座图如图\ref{fig:dvbt_map_16QAM}。
	\input{figures/dvbt_map_16QAM.tex}
	\section{参考信号}
	\section{IFFT}
	\section{OFDM循环前缀}
	\section{常数}
	\section{重采样}
		\par 信号的采样率，用于满足另一个系统的要求
	\section{USRP发射}
